<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bloomf (bloomf.Bloomf)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">bloomf</a> &#x00BB; Bloomf</nav><h1>Module <code>Bloomf</code></h1><p>Bloom filters</p><p>bloomf is an implementation of Bloom filters in OCaml.</p><p>Bloom filters are memory and time efficient data structures allowing probabilistic membership queries in a set. A query negative result ensures that the element is not present in the set, while a positive result might be a false positive, i.e. the element might not be present and the BF membership query can return true anyway. Internal parameters of the BF allow to control its false positive rate depending on the expected number of elements in it.</p><nav class="toc"><ul><li><a href="#generic-interface">Generic interface</a><ul><li><a href="#serializers/deserializers">Serializers/Deserializers</a></li></ul></li><li><a href="#functorial-interface">Functorial interface</a></li></ul></nav></header><section><header><h2 id="generic-interface"><a href="#generic-interface" class="anchor"></a>Generic interface</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>The type of the Bloom filter.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;error_rate:float</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>create ~error_rate size</code> creates a fresh BF for which expected false positive rate when filled with <code>size</code> elements is <code>error_rate</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>error_rate</code> is not in ]0, 1[, or <code>size</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add t e</code> adds <code>e</code> to <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem t e</code> is <code>true</code> if <code>e</code> is in <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>clear t</code> clears the contents of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union t1 t2</code> computes the union of the two inputs. This operation is lossless in the sense that the resulting Bloom filter is the same as the Bloom filter created from scratch using the union of the two sets.</p><p>Raises <code>Invalid_argument</code> if the two bloom filters were created with different parameters</p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>inter t1 t2</code> computes the intersection of the two inputs. The false positive probability in the resulting Bloom filter is at most the false-positive probability in one of the constituent Bloom filters, but may be larger than the false positive probability in the Bloom filter created from scratch using the intersection of the two sets.</p><p>Raises <code>Invalid_argument</code> if the two bloom filters were created with different parameters</p></dd></dl><dl><dt class="spec value" id="val-size_estimate"><a href="#val-size_estimate" class="anchor"></a><code><span class="keyword">val</span> size_estimate : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size_estimate t</code> is an approximation of the number of elements stored in the bloom filter. Please note that this operation is costly (see benchmarks).</p></dd></dl><section><header><h3 id="serializers/deserializers"><a href="#serializers/deserializers" class="anchor"></a>Serializers/Deserializers</h3></header><dl><dt class="spec value" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bytes</code></dt><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : bytes <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt></dl></section></section><section><header><h2 id="functorial-interface"><a href="#functorial-interface" class="anchor"></a>Functorial interface</h2></header><aside><p>The functorial interface allows you to specify your own hash function.</p></aside><dl><dt class="spec module-type" id="module-type-Hashable"><a href="#module-type-Hashable" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Hashable/index.html">Hashable</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The input interface for <code>Bloomf.Make</code>.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-H/index.html">H</a> : <a href="index.html#module-type-Hashable">Hashable</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output interface for <code>Bloomf.Make</code>.</p></dd></dl></section></div></body></html>